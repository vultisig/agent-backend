// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: conversations.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveConversation = `-- name: ArchiveConversation :execrows
UPDATE agent_conversations
SET archived_at = NOW(), updated_at = NOW()
WHERE id = $1 AND public_key = $2 AND archived_at IS NULL
`

type ArchiveConversationParams struct {
	ID        pgtype.UUID `json:"id"`
	PublicKey string      `json:"public_key"`
}

func (q *Queries) ArchiveConversation(ctx context.Context, arg *ArchiveConversationParams) (int64, error) {
	result, err := q.db.Exec(ctx, archiveConversation, arg.ID, arg.PublicKey)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const countConversations = `-- name: CountConversations :one
SELECT COUNT(*) FROM agent_conversations
WHERE public_key = $1 AND archived_at IS NULL
`

func (q *Queries) CountConversations(ctx context.Context, publicKey string) (int64, error) {
	row := q.db.QueryRow(ctx, countConversations, publicKey)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createConversation = `-- name: CreateConversation :one

INSERT INTO agent_conversations (public_key)
VALUES ($1)
RETURNING id, public_key, title, summary, summary_up_to, created_at, updated_at, archived_at
`

// Conversations table queries
func (q *Queries) CreateConversation(ctx context.Context, publicKey string) (*AgentConversation, error) {
	row := q.db.QueryRow(ctx, createConversation, publicKey)
	var i AgentConversation
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.Title,
		&i.Summary,
		&i.SummaryUpTo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getConversationByID = `-- name: GetConversationByID :one
SELECT id, public_key, title, summary, summary_up_to, created_at, updated_at, archived_at FROM agent_conversations
WHERE id = $1 AND public_key = $2 AND archived_at IS NULL
`

type GetConversationByIDParams struct {
	ID        pgtype.UUID `json:"id"`
	PublicKey string      `json:"public_key"`
}

func (q *Queries) GetConversationByID(ctx context.Context, arg *GetConversationByIDParams) (*AgentConversation, error) {
	row := q.db.QueryRow(ctx, getConversationByID, arg.ID, arg.PublicKey)
	var i AgentConversation
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.Title,
		&i.Summary,
		&i.SummaryUpTo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getConversationSummaryWithCursor = `-- name: GetConversationSummaryWithCursor :one
SELECT summary, summary_up_to FROM agent_conversations
WHERE id = $1 AND public_key = $2
`

type GetConversationSummaryWithCursorParams struct {
	ID        pgtype.UUID `json:"id"`
	PublicKey string      `json:"public_key"`
}

type GetConversationSummaryWithCursorRow struct {
	Summary     pgtype.Text        `json:"summary"`
	SummaryUpTo pgtype.Timestamptz `json:"summary_up_to"`
}

func (q *Queries) GetConversationSummaryWithCursor(ctx context.Context, arg *GetConversationSummaryWithCursorParams) (*GetConversationSummaryWithCursorRow, error) {
	row := q.db.QueryRow(ctx, getConversationSummaryWithCursor, arg.ID, arg.PublicKey)
	var i GetConversationSummaryWithCursorRow
	err := row.Scan(&i.Summary, &i.SummaryUpTo)
	return &i, err
}

const listConversations = `-- name: ListConversations :many
SELECT id, public_key, title, summary, summary_up_to, created_at, updated_at, archived_at FROM agent_conversations
WHERE public_key = $1 AND archived_at IS NULL
ORDER BY updated_at DESC
LIMIT $2 OFFSET $3
`

type ListConversationsParams struct {
	PublicKey string `json:"public_key"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListConversations(ctx context.Context, arg *ListConversationsParams) ([]*AgentConversation, error) {
	rows, err := q.db.Query(ctx, listConversations, arg.PublicKey, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AgentConversation{}
	for rows.Next() {
		var i AgentConversation
		if err := rows.Scan(
			&i.ID,
			&i.PublicKey,
			&i.Title,
			&i.Summary,
			&i.SummaryUpTo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConversationSummaryWithCursor = `-- name: UpdateConversationSummaryWithCursor :execrows
UPDATE agent_conversations
SET summary = $1, summary_up_to = $2, updated_at = NOW()
WHERE id = $3 AND public_key = $4
`

type UpdateConversationSummaryWithCursorParams struct {
	Summary     pgtype.Text        `json:"summary"`
	SummaryUpTo pgtype.Timestamptz `json:"summary_up_to"`
	ID          pgtype.UUID        `json:"id"`
	PublicKey   string             `json:"public_key"`
}

func (q *Queries) UpdateConversationSummaryWithCursor(ctx context.Context, arg *UpdateConversationSummaryWithCursorParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateConversationSummaryWithCursor,
		arg.Summary,
		arg.SummaryUpTo,
		arg.ID,
		arg.PublicKey,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateConversationTitle = `-- name: UpdateConversationTitle :execrows
UPDATE agent_conversations
SET title = $1, updated_at = NOW()
WHERE id = $2 AND public_key = $3 AND archived_at IS NULL
`

type UpdateConversationTitleParams struct {
	Title     pgtype.Text `json:"title"`
	ID        pgtype.UUID `json:"id"`
	PublicKey string      `json:"public_key"`
}

func (q *Queries) UpdateConversationTitle(ctx context.Context, arg *UpdateConversationTitleParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateConversationTitle, arg.Title, arg.ID, arg.PublicKey)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
